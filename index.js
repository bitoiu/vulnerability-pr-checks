if (process.env.ROLLBAR_ENABLED === 'true') {
  var Rollbar = require("rollbar");
  var rollbar = new Rollbar({
    accessToken: process.env.ROLLBAR_TOKEN,
    captureUncaught: true,
    captureUnhandledRejections: true,
    environment: process.env.ENV
  })
  rollbar.info("PR Vulnerability checks started");
}

const graphQL = require('./graphQL.js')
const ignoreDismissed = true

const status = {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  QUEUED: 'QUEUED'
}
const conclusion = {
  ACTION_REQUIRED: 'ACTION_REQUIRED',
  CANCELLED: 'CANCELLED',
  FAILURE: 'FAILURE',
  NEUTRAL: 'NEUTRAL',
  SUCCESS: 'SUCCESS',
  TIMED_OUT: 'TIMED_OUT'
}

const outputs = {
  processFailure: {
    title: 'Fatal Error',
    summary: 'The check failed due to a fatal error.',
    text: "The application wasn't able to complete the checks because of a fatal error. Check if this repository has [opted-in to the Data Services](https://help.github.com/en/articles/opting-into-or-out-of-data-use-for-your-private-repository) that allows the app to consume the necessary APIs. If this isn't the problem open an issue at https://github.com/bitoiu/vulnerability-pr-checks/issues"
  },
  failure: {
    title: 'Vulnerabilities found.',
    summary: 'Check has failed because the repository has security vulnerabilities.',
    text: "The app has found #vulnerabilities# vulnerabilities (#active# active, #dismissed# dismissed). To check more details go to Insights -> Alerts. **Note**: Currently vulnerability alerts are only indexed for the `master` branch which means fixing the vulnerabilities in this branch won't have an impact on the check. To address this issue raise a separate pull request to fix the vulnerabilities and return to this pull request upon doing so. "
  },
  success: {
    title: 'No vulnerabilities found.',
    summary: 'Check has passed. No security vulnerabilities found',
    text: null,
    warningText: 'This application has been configured to ignore dismissed but present security vulnerabilities. **Currently there are #dismissed# security vulnerabilities in this repository.**,To check more details go to Insights -> Alerts.'
  }

}

module.exports = app => {
  app.on('push', async context => {
    app.log.trace(`push event payload: ${JSON.stringify(context)}`)

    const checkRunId = await createPendingCheckRun(context)
    try {
      const repositoryVulnerabilities = await getVulnerabilityAlerts(context)
      app.log.trace(`repository vulnerabilities: ${JSON.stringify(repositoryVulnerabilities)}`)
      createFinalCheckResult(repositoryVulnerabilities, checkRunId, context)
    } catch (error) {
      updateCheckRunWithProcessFailure(checkRunId, context, error)
    }
  })
}

async function getVulnerabilityAlerts (context) {
  const vulnerabilityAlertVariables = {
    'owner': context.payload.repository.owner.name,
    'repository': context.payload.repository.name
  }

  return context.github.query(
    graphQL.getVulnerabilityAlertsQuery,
    vulnerabilityAlertVariables,
    { 'Accept': 'application/vnd.github.vixen-preview+json' })
}

async function createPendingCheckRun (context) {
  const checkRunVariables = {
    'headSha': context.payload.head_commit.id,
    'repositoryNodeId': context.payload.repository.node_id,
    'status': status.IN_PROGRESS
  }

  const createCheckRunResult = await context.github.query(
    graphQL.createRunCheckMutation,
    checkRunVariables,
    { 'Accept': 'application/vnd.github.antiope-preview+json' })

  const checkRunId = createCheckRunResult.createCheckRun.checkRun.id
  context.log.info(`Created new check run with id: ${checkRunId}`)
  return checkRunId
}

function createFinalCheckResult (repositoryVulnerabilities, checkRunId, context) {
  if (isEmptyVulnerabilitySet(repositoryVulnerabilities)) {
    updateCheckRunWithSuccess(checkRunId, context)
  } else {
    const parsedVulnerabilities = parseRepositoryVulnerabilities(repositoryVulnerabilities)
    context.log.info(`vulnerabilities breakdown: ${JSON.stringify(parsedVulnerabilities)}`)

    if (ignoreDismissed === true & parsedVulnerabilities.active.length === 0) {
      updateCheckRunWithSuccess(checkRunId, context, parsedVulnerabilities)
    } else {
      updateCheckRunWithFailure(checkRunId, context, parsedVulnerabilities)
    }
  }
}

function parseRepositoryVulnerabilities (repositoryVulnerabilities) {
  let parsedVulnerabilities = {
    active: [],
    dismissed: []
  }

  repositoryVulnerabilities.repository.vulnerabilityAlerts.edges.forEach(element => {
    if (element.node.dismissedAt === null) {
      parsedVulnerabilities.active.push(element)
    } else {
      parsedVulnerabilities.dismissed.push(element)
    }
  })

  return parsedVulnerabilities
}

function updateCheckRunWithSuccess (checkRunId, context, parsedVulnerabilities) {
  const showWarningText = ignoreDismissed && parsedVulnerabilities.dismissed.length > 0
  const updateCheckRunVariables = {
    'repositoryNodeId': context.payload.repository.node_id,
    'checkRunId': checkRunId,
    'status': status.COMPLETED,
    'conclusion': conclusion.SUCCESS,
    'completedAt': nowISO(),
    'outputSummary': outputs.success.summary,
    'outputTitle': outputs.success.title,
    'outputText': showWarningText
      ? outputs.success.warningText.replace('#dismissed#', parsedVulnerabilities.dismissed.length)
      : outputs.success.text

  }

  context.github.query(
    graphQL.updateCheckRunMutationWithOutput,
    updateCheckRunVariables,
    { 'Accept': 'application/vnd.github.antiope-preview+json' })
}

function updateCheckRunWithFailure (checkRunId, context, parsedVulnerabilities) {
  const dismissedCount = parsedVulnerabilities.dismissed.length

  const activeCount = parsedVulnerabilities.active.length
  const variables = {
    'repositoryNodeId': context.payload.repository.node_id,
    'checkRunId': checkRunId,
    'status': status.COMPLETED,
    'conclusion': conclusion.FAILURE,
    'completedAt': nowISO(),
    'outputSummary': outputs.failure.summary,
    'outputTitle': outputs.failure.title,
    'outputText': outputs.failure.text
      .replace('#vulnerabilities#', dismissedCount + activeCount)
      .replace('#active#', activeCount)
      .replace('#dismissed#', dismissedCount)
  }

  context.github.query(
    graphQL.updateCheckRunMutationWithOutput,
    variables,
    { 'Accept': 'application/vnd.github.antiope-preview+json' })
}

function updateCheckRunWithProcessFailure (checkRunId, context, error) {
  const variables = {
    'repositoryNodeId': context.payload.repository.node_id,
    'checkRunId': checkRunId,
    'status': status.COMPLETED,
    'conclusion': conclusion.FAILURE,
    'completedAt': nowISO(),
    'outputSummary': outputs.processFailure.summary,
    'outputTitle': outputs.processFailure.title,
    'outputText': outputs.processFailure.text + '\n\n Runtime Error: ```' + error + '```'
  }

  context.github.query(
    graphQL.updateCheckRunMutationWithOutput,
    variables,
    { 'Accept': 'application/vnd.github.antiope-preview+json' })
}

function isEmptyVulnerabilitySet (vulnerabilityAlertsResult) {
  return vulnerabilityAlertsResult.repository.vulnerabilityAlerts.edges.length === 0
}

function nowISO () {
  return new Date().toISOString()
}
